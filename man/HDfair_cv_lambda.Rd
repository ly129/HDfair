% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/HDfair_cv_lambda.R
\name{HDfair_cv_lambda}
\alias{HDfair_cv_lambda}
\title{HDfair_cv_lambda: Cross-Validation for Optimal Lambda}
\usage{
HDfair_cv_lambda(
  X,
  y,
  ma,
  lambda_length,
  lambda_ratio,
  nfold,
  foldid = NULL,
  eta,
  rho,
  weighted = FALSE,
  adj = 1,
  eps = 1e-06,
  maxiter = 10000,
  verbose = FALSE
)
}
\arguments{
\item{X}{Numeric matrix of dimension \eqn{n \times p}; the design matrix.}

\item{y}{Numeric vector of length \eqn{n}; the response variable.}

\item{ma}{Integer matrix of dimension \eqn{n \times 2}; first column is source indicator (1,2,...), second column is group indicator (1,2,...).}

\item{lambda_length}{Integer; number of \eqn{\lambda} values to evaluate when \code{lambda_seq} is NULL.}

\item{lambda_ratio}{Numeric scalar; ratio between the smallest and largest \eqn{\lambda} (\eqn{\lambda_{min}/\lambda_{max}}) when auto-generating the sequence.}

\item{nfold}{Integer; number of CV folds.}

\item{foldid}{Integer vector of length \eqn{n}; pre-specified fold assignments. If NULL, folds are generated by stratifying on source-group combinations.}

\item{eta}{Numeric scalar; fairness-penalty parameter (fixed across folds).}

\item{rho}{Numeric scalar; augmented Lagrangian parameter for optimization (fixed).}

\item{weighted}{Logical; if TRUE, use the weighted loss (sum of mean losses per source-group) in CV error calculation; otherwise, use unweighted sum of squared errors.}

\item{adj}{Numeric scalar; multiplier adjustment factor (passed to \code{HDfair}).}

\item{eps}{Numeric scalar; convergence tolerance for HDfair iterations.}

\item{maxiter}{Integer; maximum number of iterations for HDfair.}

\item{verbose}{Logical; if TRUE, prints progress during CV.}
}
\value{
An object of class \code{"HDfair_cv"}, which is a list containing:
\describe{
  \item{lambda}{Numeric vector of evaluated \eqn{\lambda} values.}
  \item{cvm}{Numeric vector of mean CV error for each \eqn{\lambda}.}
  \item{cvsd}{Numeric vector of standard error of CV error.}
  \item{cvup}{Numeric vector of \code{cvm + cvsd}.}
  \item{cvlo}{Numeric vector of \code{cvm - cvsd}.}
  \item{nzero}{Integer array of dimension \eqn{M \times A \times L} where \eqn{L} is \code{lambda_length}; number of nonzero coefficients per source-group and \eqn{\lambda}.}
  \item{lambda.min}{Selected \eqn{\lambda} with minimum \code{cvm}.}
  \item{lambda.1se}{Largest \eqn{\lambda} within one standard error of the minimum \code{cvm}.}
  \item{index}{Named integer vector with indices \code{lam.min} and \code{lam.1se}.}
  \item{foldid}{Integer vector of length \eqn{n}; fold assignments used.}
  \item{sp}{Result of \code{HDfair_sp_lambda} on full data (solution path).}
}
}
\description{
Performs K-fold cross-validation over a sequence of \eqn{\lambda} values to select an optimal
tuning parameter for HDfair, using warm-started solution paths from \code{HDfair_sp_lambda}.
}
