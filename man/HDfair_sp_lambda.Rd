% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/HDfair_sp_lambda.R
\name{HDfair_sp_lambda}
\alias{HDfair_sp_lambda}
\title{HDfair_sp_lambda: Compute HDfair Solution Path over Lambda}
\usage{
HDfair_sp_lambda(
  X,
  y,
  ma,
  lambda_length = 10,
  lambda_ratio = 0.01,
  lambda_seq = NULL,
  eta,
  rho,
  weighted = FALSE,
  adj = 1,
  eps = 1e-06,
  maxiter = 10000,
  verbose = FALSE
)
}
\arguments{
\item{X}{Numeric matrix of dimension \eqn{n \times p}; the design matrix.}

\item{y}{Numeric vector of length \eqn{n}; the response variable.}

\item{ma}{Integer matrix of dimension \eqn{n \times 2}; the first column is the source indicator and the second column is the group indicator.}

\item{lambda_length}{Integer; number of \eqn{\lambda} values in the default sequence (ignored if \code{lambda_seq} is provided).}

\item{lambda_ratio}{Numeric; ratio between the smallest and largest \eqn{\lambda} in the default sequence (ignored if \code{lambda_seq} is provided).}

\item{lambda_seq}{Numeric vector; optional user-specified sequence of \eqn{\lambda} values. If provided, overrides \code{lambda_length} and \code{lambda_ratio}.}

\item{eta}{Numeric scalar; fairness-penalty parameter (constraint threshold).}

\item{rho}{Numeric scalar; augmented Lagrangian parameter.}

\item{weighted}{Logical; if \code{TRUE}, computes the loss as the sum of mean losses over sources and groups; if \code{FALSE}, computes loss as the sum over all observations.}

\item{adj}{Numeric scalar; optional factor applied to the Lagrangian multiplier updates.}

\item{eps}{Numeric scalar; convergence tolerance based on the L2 norm of the coefficient updates.}

\item{maxiter}{Integer; maximum number of augmented Lagrangian iterations per \eqn{\lambda}.}

\item{verbose}{Logical; if \code{TRUE}, prints iteration details (e.g., parameter updates and multiplier values) for each \eqn{\lambda}.}
}
\value{
An object of class "HDfair_sp" with components:
\describe{
  \item{estimates}{Array of dimension \eqn{p \times A \times M \times L}, where \eqn{L} is the number of \eqn{\lambda} values; estimated coefficients for each source/group and \eqn{\lambda}.}
  \item{lambdas}{Numeric vector of \eqn{\lambda} values used.}
  \item{iterations}{Integer vector of length \eqn{L}; iterations taken to converge for each \eqn{\lambda}.}
  \item{g}{Matrix of dimension \eqn{A \times L}; final fairness penalty values for each group and \eqn{\lambda}.}
}
}
\description{
Computes HDfair coefficient estimates across a sequence of \eqn{\lambda} values for a fixed \code{eta}, using warm starts to improve computational efficiency.
Returns an object of class "HDfair_sp" containing estimates, lambda sequence, iteration counts, and fairness penalty values for each \eqn{\lambda}.
}
\seealso{
\code{\link{HDfair}}, \code{\link{plot_sp_lambda}}
}
